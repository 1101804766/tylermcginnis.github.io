<!DOCTYPE html>
 <html lang="en"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1.0 maximum-scale=5.0"/><title>Tyler McGinnis</title><style>html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,cite,code,details,figcaption,figure,footer,header,hgroup,main,nav,section,small,summary{display:block}article,article ol,article ul,blockquote,body,div,figure,footer,header,input,nav,section{box-sizing:border-box}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:transparent}a:active,a:hover{outline:0}abbr{letter-spacing:.1em}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:600}dfn{font-style:italic}mark{background:#ff0;color:#000}small{font-size:70%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}em,i{line-height:0;position:relative;vertical-align:baseline}img{border:0}svg:not(:root){overflow:hidden}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}img{max-width:100%;display:block;margin:inherit auto}.wrapper{max-width:1070px;margin-left:auto;margin-right:auto}.wrapper:after,.wrapper:before{content:"";display:table}.wrapper:after{clear:both}.content{width:calc(99.9% * 2/3 - 10px)}.content:nth-child(1n){float:left;margin-right:30px;clear:none}.content:last-child{margin-right:0}.content:nth-child(3n){margin-right:0;float:right}.content:nth-child(3n+1){clear:both}.main-inner{padding:40px 35px}@media screen and (max-width:1100px){.content{width:calc(99.9% * 2/4 - 15px)}.content:nth-child(1n){float:left;margin-right:30px;clear:none}.content:last-child{margin-right:0}.content:nth-child(4n){margin-right:0;float:right}.content:nth-child(4n+1){clear:both}.main-inner{padding:35px 20px}}@media screen and (max-width:900px){.content{width:calc(99.9% * 7/12 - 12.5px)}.content:nth-child(1n){float:left;margin-right:30px;clear:none}.content:last-child{margin-right:0}.content:nth-child(12n){margin-right:0;float:right}.content:nth-child(12n+1){clear:both}.main-inner{padding:30px 20px}}@media screen and (max-width:500px){.content{width:calc(99.9% * 4/4 - 0px)}.content:nth-child(1n){float:left;margin-right:30px;clear:none}.content:last-child{margin-right:0}.content:nth-child(4n){margin-right:0;float:right}.content:nth-child(4n+1){clear:both}.main-inner{padding:25px 20px}}@media screen and (min-width:40em){.floatLeft{float:left}}@media screen and (min-width:40em){.floatCenter{margin-left:auto;margin-right:auto}}@media screen and (min-width:40em){.floatRight{float:right}}@media screen and (min-width:40em){body,html{margin:0;width:100%;max-width:none}}html{box-sizing:border-box;font-size:16px;font-size:100%;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen-Sans,Ubuntu,Cantarell,Helvetica Neue,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;color:#222;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}@media screen and (min-width:40em){html{font-size:18px;font-size:1.125rem}}*,:after,:before{box-sizing:inherit}body{margin:0}footer{display:block}body>footer{margin:0 auto;width:80%}header,main,section{display:block}a{background:transparent;color:#222;text-decoration:none;-webkit-transition:all .3s;transition:all .3s}a:active,a:hover{outline:0}a:active,a:hover{color:#222}article{display:block;margin:0 auto;width:80%}@media screen and (min-width:40em){article{max-width:945px;max-width:52.5rem}}audio{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}canvas{display:inline-block;vertical-align:baseline}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace}code{padding:26px;padding:1.625rem;display:block}@media screen and (min-width:40em){code{padding:31px;padding:1.722222222222222rem}}details,figcaption,summary{display:block}figcaption{line-height:26px;line-height:1.625rem;color:#222;font-size:.8125rem;font-style:italic;margin-bottom:0;text-align:center}@media screen and (min-width:40em){figcaption{line-height:31px;line-height:1.722222222222222rem;margin-bottom:0}}figure{display:block}@media screen and (min-width:40em){figure.floatLeft,figure.floatRight{max-width:315px;max-width:17.5rem;padding:0 31px;padding:0 1.722222222222222rem}}@media screen and (min-width:40em){figure.floatLeft blockquote,figure.floatRight blockquote{padding:0;text-align:left}}@media screen and (min-width:40em){figure.floatLeft blockquote p,figure.floatRight blockquote p{font-size:19.2px;font-size:1.2rem;line-height:31px;line-height:1.722222222222222rem}}h1{font-size:40px;font-size:2.5rem;line-height:52px;line-height:3.25rem;margin-top:104px;margin-top:6.5rem;margin-bottom:26px;margin-bottom:1.625rem}h2{font-size:27px;font-size:1.6875rem;line-height:39px;line-height:2.4375rem;margin-top:65px;margin-top:4.0625rem;margin-bottom:13px;margin-bottom:.8125rem}h3{font-size:22px;font-size:1.375rem;margin-top:52px;margin-top:3.25rem}h3,h4{line-height:26px;line-height:1.625rem;margin-bottom:13px;margin-bottom:.8125rem}h4{font-size:19.2px;font-size:1.2rem;margin-top:39px;margin-top:2.4375rem}h5,h6{font-size:16px;font-size:1rem;line-height:26px;line-height:1.625rem;margin-top:65px;margin-top:4.0625rem;margin-bottom:13px;margin-bottom:.8125rem}@media screen and (min-width:40em){h1{font-size:40px;font-size:2.5rem;line-height:62px;line-height:3.444444444444445rem;margin-top:124px;margin-top:6.888888888888889rem;margin-bottom:31px;margin-bottom:1.722222222222222rem}h2{font-size:27px;font-size:1.6875rem;line-height:46.5px;line-height:2.583333333333334rem;margin-top:77.5px;margin-top:4.305555555555556rem;margin-bottom:15.5px;margin-bottom:.861111111111111rem}h3{font-size:22px;font-size:1.375rem;margin-top:62px;margin-top:3.444444444444445rem}h3,h4{line-height:31px;line-height:1.722222222222222rem;margin-bottom:15.5px;margin-bottom:.861111111111111rem}h4{font-size:19.2px;font-size:1.2rem;margin-top:46.5px;margin-top:2.583333333333334rem}h5,h6{font-size:16px;font-size:1rem;line-height:31px;line-height:1.722222222222222rem;margin-top:77.5px;margin-top:4.305555555555556rem;margin-bottom:15.5px;margin-bottom:.861111111111111rem}}h1+h2{margin-top:26px;margin-top:1.625rem}@media screen and (min-width:40em){h1+h2{margin-top:31px;margin-top:1.722222222222222rem}}h2+h3,h3+h4,h4+h5{margin-top:13px;margin-top:.8125rem}@media screen and (min-width:40em){h2+h3,h3+h4,h4+h5{margin-top:15.5px;margin-top:.861111111111111rem}}h5+h6{margin-top:-13px;margin-top:-.8125rem}@media screen and (min-width:40em){h5+h6{margin-top:-15.5px;margin-top:-.861111111111111rem}}h6{font-style:italic;font-weight:400}hgroup,hr{display:block}hr{margin-top:52px;margin-bottom:52px;box-sizing:content-box;border:0;color:#222;height:26px;height:1.625rem;margin:3.25rem auto;background-size:100% 26px;background-size:100% 1.625rem;background-image:-webkit-linear-gradient(top,transparent 1px,transparent 11px,#222 0,#222 15px,transparent 0,transparent 26px);background-image:linear-gradient(180deg,transparent 1px,transparent 11px,#222 0,#222 15px,transparent 0,transparent 26px);width:100px}@media screen and (min-width:40em){hr{background-size:100% 31px;background-size:100% 1.722222222222222rem;background-image:-webkit-linear-gradient(top,transparent 1px,transparent 13.5px,#222 0,#222 17.5px,transparent 0,transparent 31px);background-image:linear-gradient(180deg,transparent 1px,transparent 13.5px,#222 0,#222 17.5px,transparent 0,transparent 31px);margin-top:62px;margin-top:3.444444444444445rem;margin-bottom:62px;margin-bottom:3.444444444444445rem;height:31px;height:1.722222222222222rem}}img{border:0;max-width:100%;display:block;margin:inherit auto}svg:not(:root){overflow:hidden}ol li,ul li{margin-bottom:0}nav{display:block}progress{display:inline-block;vertical-align:baseline}blockquote{font-style:italic;padding-left:1.4375rem}@media screen and (min-width:40em){blockquote{padding-left:2rem}}cite{display:block;font-style:normal}figure blockquote{padding:26px 0;padding:1.625rem 0}@media screen and (min-width:40em){figure blockquote{padding:62px 0 31px;padding:3.444444444444445rem 0 1.722222222222222rem;text-align:center}}figure blockquote p{font-size:27px;font-size:1.6875rem;line-height:39px;line-height:2.4375rem}@media screen and (min-width:40em){figure blockquote p{font-size:27px;font-size:1.6875rem;line-height:46.5px;line-height:2.583333333333334rem}}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}[hidden],template{display:none}abbr{letter-spacing:.1em}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:600}dfn{font-style:italic}em,i{line-height:0;position:relative;vertical-align:baseline}mark{background:#ff0;color:#000}small{line-height:13px;line-height:.8125rem;font-size:70%}@media screen and (min-width:40em){small{line-height:15.5px;line-height:.861111111111111rem}}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}.attention-grabber{font-size:19.2px;font-size:1.2rem}.alignLeft{text-align:left}.alignCenter{text-align:center}.alignRight{text-align:right}.uppercase{letter-spacing:.1em;text-transform:uppercase}video{display:inline-block;vertical-align:baseline}.blog-post{margin:40px 0}.blog-post:last-child{margin-bottom:10px}.blog-post h2{margin-top:10px;line-height:30px;margin-bottom:20px}.blog-post h2 a:hover{border-bottom:1px solid}.blog-post p{font-size:16px;line-height:26px;margin-bottom:10px}.blog-post .blog-category,.blog-post time{font-size:14px;color:rgba(0,0,0,.8);font-weight:500;text-transform:uppercase}.blog-post .readmore{font-size:16px;color:rgba(0,0,0,.8)}.blog-post .readmore:hover{border-bottom:1px solid}.blog-single{max-width:945px;margin-left:auto;margin-right:auto}.blog-single code{font-size:18px}.blog-single h1{text-align:center;margin-top:30px;font-weight:500;text-align:left;font-size:40px;line-height:1.04}.blog-single .text{line-height:31px;margin-bottom:31px;font-size:21px}.blog-single blockquote{background:transparent;padding:10px 25px;margin:40px 0;border-left:.5px solid #000;position:relative;margin-right:-64px;text-align:left;font-size:18px}.blog-body{line-height:1.58}.blog-body a{text-decoration:underline}.blog-single .date-published,.blog-single .text :not(div),.blog-single h1{max-width:740px;margin-left:auto;margin-right:auto}.date-published{font-size:16px;padding:20px 16px;margin:0;line-height:normal;text-align:right}.blog-single .text img{max-width:100%;height:auto;margin:30px 0}.blog-single .footer{max-width:740px;margin-left:auto;margin-right:auto;line-height:31px;margin-bottom:31px}.gohome{position:fixed;left:20px;font-size:16px;padding:20px 16px;color:rgba(0,0,0,.8);font-weight:400;border-radius:3px}.gohome:hover{cursor:pointer;font-weight:500}@media (max-width:900px){.blog-single h1{margin-top:15px}.blog-single .footer,.blog-single .text{padding:0 15px;line-height:26px;margin-bottom:26px}.gohome{position:static;margin:20px auto 0;text-align:center;width:85px;display:block}}p>code,span>code{border-radius:3px;white-space:pre;white-space:pre-wrap;white-space:pre-line;white-space:-pre-wrap;white-space:-o-pre-wrap;white-space:-moz-pre-wrap;white-space:-hp-pre-wrap;word-wrap:break-word;background:#f8f8f8;display:inline;font-family:Inconsolata,monospace,serif;max-width:100%;overflow:auto;padding:.25em .5em}pre code{border-radius:3px;padding:.5em 1em;color:#333;background:transparent}.hljs,pre code{display:block;overflow-x:auto}.hljs{padding:.5em;background:#222;color:#fff}.hljs-comment,.hljs-quote{color:#777}.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-deletion,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-regexp,.hljs-symbol,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ab875d}.hljs-attribute,.hljs-name,.hljs-section,.hljs-selector-class,.hljs-selector-id,.hljs-title,.hljs-type{color:#9b869b}.hljs-addition,.hljs-keyword,.hljs-selector-tag,.hljs-string{color:#8f9c6c}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}.blog-nav{margin:20px 0 10px}.blog-nav ul{list-style:none;padding-left:0}.blog-nav ul li{margin:10px 0}.blog-nav ul li a{font-size:16px;line-height:26px;margin-bottom:26px;border-bottom:0;font-weight:400;color:rgba(0,0,0,.8)}.blog-nav ul li a.current,.blog-nav ul li a:hover{border-bottom:1px solid}.blog-social{margin-top:30px}.blog-social ul:after,.blog-social ul:before{content:" ";display:table}.blog-social ul:after{clear:both}.blog-social ul{list-style:none;padding:0;margin:10px 0;zoom:1}.blog-social ul>li{float:left;margin-right:5px;text-align:center;height:24px;width:24px;border-radius:3px;background:#f4f4f4}.blog-social ul>li:hover{background:#f4f4f4}.blog-social ul>li>a{border-bottom:0}.blog-social ul>li>a>i{color:rgba(0,0,0,.8);font-size:14px;line-height:24px}.blog-social ul>li:hover a>i{color:rgba(0,0,0,.6)}.sidebar{width:calc(99.9% * 1/3 - 20px)}.sidebar:nth-child(1n){float:left;margin-right:30px;clear:none}.sidebar:last-child{margin-right:0}.sidebar:nth-child(3n){margin-right:0;float:right}.sidebar:nth-child(3n+1){clear:both}.sidebar .sidebar-inner{position:relative;padding:40px}.sidebar .sidebar-inner:after{background:#eee;background:-webkit-linear-gradient(top,#eee,#eee 48%,#fff);background:linear-gradient(180deg,#eee 0,#eee 48%,#fff);position:absolute;content:"";width:1px;height:540px;top:30px;right:-10px;bottom:0}.sidebar .sidebar-inner img{display:inline-block;margin-bottom:0;border-radius:50%;background-clip:padding-box}.sidebar .sidebar-inner h1,.sidebar .sidebar-inner h2{font-size:18px;font-weight:500;line-height:18px;margin:20px 0 10px}.sidebar .sidebar-inner p{color:rgba(0,0,0,.8);font-size:16px;line-height:26px;margin-bottom:26px}.sidebar .sidebar-inner p.copyright{color:rgba(0,0,0,.8);font-size:14px}@media (max-width:1100px){.sidebar .sidebar-inner{padding:35px 20px 0}.sidebar{width:calc(99.9% * 1/2 - 15px)}.sidebar:nth-child(1n){float:left;margin-right:30px;clear:none}.sidebar:last-child{margin-right:0}.sidebar:nth-child(2n){margin-right:0;float:right}.sidebar:nth-child(2n+1){clear:both}}@media (max-width:900px){.sidebar{width:calc(99.9% * 5/12 - 17.5px)}.sidebar:nth-child(1n){float:left;margin-right:30px;clear:none}.sidebar:last-child{margin-right:0}.sidebar:nth-child(12n){margin-right:0;float:right}.sidebar:nth-child(12n+1){clear:both}.sidebar .sidebar-inner{padding:30px 20px 0}}@media (max-width:500px){.sidebar{width:calc(99.9% * 1 - 0px)}.sidebar:nth-child(1n){float:left;margin-right:30px;clear:none}.sidebar:last-child{margin-right:0}.sidebar:nth-child(undefinedn){margin-right:0;float:right}.sidebar:nth-child(undefinedn+1){clear:both}.sidebar .sidebar-inner{padding:25px 20px 0}.sidebar .sidebar-inner:after{display:none}}.blog-page{margin-bottom:40px}.blog-page h1{font-size:calc(20px + 16 * ((100vw - 420px) / 860));margin-top:0}@media screen and (min-width:1280px){.blog-page h1{font-size:36px}}@media screen and (max-width:420px){.blog-page h1{font-size:20px}}.blog-page p{font-size:16px;line-height:26px;margin-bottom:26px}@media (max-width:900px){.blog-single .footer,.blog-single .text{padding:0 15px}}</style></head><body><div id="react-mount"><div class="wrapper" data-reactroot="" data-reactid="1" data-react-checksum="-708122690"><div data-reactid="2"><div data-reactid="3"><div data-reactid="4"><a class="gohome" href="/" data-reactid="5">Back</a></div><div class="blog-single" data-reactid="6"><div class="text" data-reactid="7"><div class="date-published" data-reactid="8">19 Jan 2015</div><h1 data-reactid="9">React Tutorial Pt 2: Building React Applications with Gulp and Browserify.</h1><div class="blog-body" data-reactid="10"><hide-from-preview>
<hr>
<p>Table of Contents:</p>
<p><a href="http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/">Pt I: A Comprehensive Guide to Building Apps with
React.js.</a></p>
<p><a href="http://tylermcginnis.com/react-js-tutorial-1-5-utilizing-webpack-and-babel-to-build-a-react-js-app/">Pt 1.5: Utilizing Webpack and Babel to build a React.js
App</a></p>
<p><strong><a href="http://tylermcginnis.com/reactjs-tutorial-pt-2-building-react-applications-with-gulp-and-browserify/">Pt II: Building React.js Apps with Gulp, and
Browserify.</a></strong></p>
<p><a href="http://tylermcginnis.com/reactjs-tutorial-pt-iii-architecting-react-js-apps-with-flux/">Pt III: Architecting React.js Apps with
Flux.</a></p>
<p><s>Pt IV: Add Routing to your React App with React Router. (Coming Soon)</s>**</p>
<p><s>Pt V: Add Data Persistence to your React App with Firebase. (Coming Soon)</s>**</p>
<p><s>Pt VI:Combining React.js, Flux, React Router, Firebase, Gulp, and Browserify. (Coming
Soon)</s>*</p>
<p>**<strong>Check out my <a href="http://reactjsprogram.com/">React.js Program</a>. It’s the successor to this blog series.</strong></p>
<hr>
<p><strong>Since writing this post I (along with most of the community) have adopted
Webpack over Gulp. This is still a great post and contains some great
information, but I recommend reading
<strong><a href="http://tylermcginnis.com/react-js-tutorial-1-5-utilizing-webpack-and-babel-to-build-a-react-js-app/">THIS</a></strong>
tutorial for actual implementation as this post is a little out of date.</strong></p>
<hr>
</hide-from-preview>
<p>In part 1 we talked about all things React.</p>
<p>At this point you should feel comfortable with the following parts of React -</p>
<pre><code>JSX
Virtual DOM
React.createClass
render (method)
React.render
state
getInitialState
setState
props
propTypes
getDefaultProps
Component LifeCycle
componentWillMount
componentDidMount
componentWillReceiveProps
componentWillUnmount
Events
onClick
onSubmit
onChange
</code></pre>
<p>If you’re not comfortable with the above, go re-read <a href="http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/">part
1</a>.</p>
<p>At this point you might have noticed that in order to actually build apps with
React, you need a way to transform your JSX into JS and also a way to
export/import components from other components (or you need to put some thought
into how you load your script tags in your HTML). This tutorial is going to
introduce Gulp as a way to transform JSX into JS (along with a few other handy
transformations). It’s also going to cover using Browserify with React in order
to be able to import/export components for the use in other components.</p>
<p><em>I realize that there are many other ways to do the JSX -&gt; JS transformation
and specifically a lot of people are using webpack for mostly all of this. Those
other ways are great. I’ve found that for beginners though, Gulp and Browserify
make a great pair which abstracts some low level complexities without
abstracting everything. I hope to build a future tutorial which uses Webpack
instead of Gulp/Browserify.</em></p>
<p>Let’s start with Gulp. If you’ve had experience with another build tool, such as
Grunt or Broccoli, this will make a lot of sense. If you have no experience with
build tools, this next section is more specifically for you.</p>
<p>Let’s talk about why we need a tool like Gulp. Think of all the cool tools
developers have built on top of things like JavaScript and CSS. Let’s use SASS
and Coffeescript as examples. One day this (or perhaps these) developers got
together and they said something along the lines of “Hey, CSS is cool, but it
has a lot of limitations. Let’s make a language that is a layer on top of CSS.
What we can do is we can create a language that is more powerful than CSS and
has a lot more features. Then all we have to do is figure out a way for our
language to have some sort of process to it which allows developers using our
language to convert it (or transpile it) to actual CSS so the browser can
understand it.” — and that’s exactly what they did. Coffeescript is another
example. That conversation probably went like this “Wow JavaScript is so ugly.
There’s not even a class keyword. We should build a language that isn’t so ugly
and then figure out how to transpile it to actual JavaScript because that’s all
the browser can understand.” A conversation similar to this most likely occurred
when the React team decided to go with this JSX idea. As long as there’s a way
to convert the “transpiled language” to a real language the browser can
understand, there’s no issue. One convenient use case for Gulp is that we can
tell Gulp that whenever we change a certain file or whenever we do some certain
event, to go ahead and take our Coffeescript, SASS, JSX (etc), and transpile it
into actual JavaScript or CSS.</p>
<p>Though having Gulp transpile your code is great, if you were only doing that,
you probably don’t need the power of Gulp since there are more basic solutions.
However, we’re going to use Gulp for more than just transpiling our JSX into JS.
Let’s think of some more things we do as developers that could be automated with
a build tool process like Gulp. Perhaps the most obvious processes are the ones
we use right before pushing our code to production. We first minify our code
(shorten variable names, remove white space, etc) in order to minimize our file
size. Next thing we usually do is concatenate all of our JavaScript files into
one file so when the client makes a request to the server for our app, it can
grab that one concatenated JavaScript file without having to worry about making
a bunch of requests to grab all of the files. Next thing you would need to do is
head over to your HTML page and change out all your <code>&lt;script&gt;</code> tags with just one,
which was the minified JavaScript file. There are a plethora of things you can
do with Gulp, we’ll stick with the most common ones for this post.</p>
<p>Now that you have a better idea of why build tools like Gulp are so handy, let’s
jump into getting started with Gulp.</p>
<p>The first thing you need to do when starting out with Gulp is to use NPM to
install Gulp globally. If you’re not familiar with NPM, download Node and then
do some googling. Using NPM is outside of the scope of this tutorial but is
fairly straight forward.</p>
<p>In your terminal run</p>
<pre><code>npm install --global gulp
</code></pre>
<p>that will install gulp globally on your computer.</p>
<p>Now, go ahead and make a new project with a folder structure that looks like
this (remember, passively reading this tutorial won’t get you very far).</p>
<pre><code>gulpfile.js
src
  index.html
  js
    App.js
    Child.js
    Parent.js
</code></pre>
<p>Head over to your <em>index.html</em> page and add the following code.</p>
<pre><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"https://cdnjs.cloudflare.com/ajax/libs/react/0.12.2/react.min.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/Child.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/Parent.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/App.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>Notice it’s pretty bare right now. All we really have is a div with an id of app
and we’re loading React from a CDN.</p>
<p>Head over to your* Child.js* file and add the following code.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> Child = React.createClass({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        and this is the <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>{this.props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>.
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
  }
});
</code></pre>
<p>One more boilerplate addition. Now head over to your Parent.js file and add the
following code.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> Parent = React.createClass({
  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> This is the parent. <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Child</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"child"</span>/&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    )
  }
});
</span></code></pre>
<p>Now head over to your <em>App.js</em> file and add the following code.</p>
<pre><code class="language-javascript">React.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Parent</span> /&gt;</span>, document.getElementById('app'));
</span></code></pre>
<p>Notice all we’re doing is creating two components, one child, one parent. The
parent component is rendered to <em>#app</em> (in <em>App.js</em>), which then renders the
child component passing in “child” as a property on props.</p>
<p>Now comes the fun part. Let’s head over to our <em>gulpfile.js</em> file and start
building out our build process. Here’s the functionality that we eventually want
from our final gulp build process.</p>
<p>Development</p>
<ol>
<li>Transform our JSX into JS and save the output into a dist/src folder.</li>
<li>Copy our index.html from our src folder into the dist folder</li>
<li>Watch changes to any JS or HTML file then run the previous two processes again.</li>
</ol>
<p>Production</p>
<ol>
<li>Take all the JS files, concat them all together, minify the result, then output
the result to one file named build.js to the build folder inside the dist
folder</li>
<li>Replace our <code>&lt;script&gt;</code> tags in our index.html page with one <code>&lt;script&gt;</code>
which references our new minified build.js file</li>
</ol>
<p>With these processes above we’ll make it very simple to prepare our code for
production and also very simple to convert our JSX to JS during development.</p>
<h4><strong>Download NPM Packages</strong></h4>
<p>The very first thing we need to do is set up our package.json file. For those
unfamiliar with what our package.json is for, it’s essentially just a collection
of the node packages that are required for our application. In your terminal,
head over to the root of this project then type **npm init **and select from the
different options (you can just hit enter until it finishes). The options don’t
matter too much - you can change them later.</p>
<p>Once you’re finished with that you’ll have a bare package.json file. Now in your
terminal run the following commands.</p>
<pre><code>npm install --save-dev gulp;
npm install --save-dev gulp-concat;
npm install --save-dev gulp-uglify;
npm install --save-dev gulp-react;
npm install --save-dev gulp-html-replace;
</code></pre>
<p>If you’ve used npm before, this is pretty straight forward. If you haven’t, we
practically just did witchcraft. All we did was tell npm to go and download each
of those packages and save them into our <em>node_modules</em> folder (which was
created for us) and add them to our <em>package.json</em> file as a developer
dependency. Now if you check out the <em>node_modules</em> folder, it should be full of
the packages above. What we can do now is in our <em>gulpfile.js</em> file, we can use
<strong>require</strong> to essentially import the code from each of the different packages
and save that functionality into a variable. Let’s do that right now.</p>
<p>In the top of your <em>gulpfile.js</em> file, add the following code.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);
<span class="hljs-keyword">var</span> concat = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-concat'</span>);
<span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>);
<span class="hljs-keyword">var</span> react = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-react'</span>);
<span class="hljs-keyword">var</span> htmlreplace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-html-replace'</span>);
</code></pre>
<p>Notice we’ve created a variable for each of the packages we downloaded earlier.
Now, each of those variables is just whatever was being exported from each
individual package.</p>
<p>Before we dive into building our different Gulp tasks, we first need to create a
paths object. This paths object is going to be filled with properties that
represent differents paths. Copy this code under your variable declarations in
our <em>gulpfile.js</em> file.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> path = {
  <span class="hljs-attr">HTML</span>: <span class="hljs-string">'src/index.html'</span>,
  <span class="hljs-attr">ALL</span>: [<span class="hljs-string">'src/js/*.js'</span>, <span class="hljs-string">'src/js/**/*.js'</span>, <span class="hljs-string">'src/index.html'</span>],
  <span class="hljs-attr">JS</span>: [<span class="hljs-string">'src/js/*.js'</span>, <span class="hljs-string">'src/js/**/*.js'</span>],
  <span class="hljs-attr">MINIFIED_OUT</span>: <span class="hljs-string">'build.min.js'</span>,
  <span class="hljs-attr">DEST_SRC</span>: <span class="hljs-string">'dist/src'</span>,
  <span class="hljs-attr">DEST_BUILD</span>: <span class="hljs-string">'dist/build'</span>,
  <span class="hljs-attr">DEST</span>: <span class="hljs-string">'dist'</span>
};
</code></pre>
<p>Now that are paths are defined, let’s create our first gulp task.</p>
<h4><strong>Gulp Tasks for Development</strong></h4>
<p>Our first task is going to be called transform and it’s going to be what
transforms our JSX into JS. The code for this task looks like this,</p>
<pre><code>gulp.task(<span class="hljs-string">'transform'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
  gulp.src(path.JS)
    .pipe(react())
    .pipe(gulp.dest(path.DEST_SRC));
});
</code></pre>
<p>Perhaps the coolest thing about Gulp is its ability to pipe and chain function
invocations. What this means is that we’re able to take one file, transform it
and do something with it, then take that transformation and do something else
with it, then when we’re finished, tell it where to put the newly created file.
That’s exactly what we’re doing above. We create a gulp task called transform
and pass it a callback function. In our callback function we grab the <em>path.JS
array</em>. Gulp then gets each one of those files, transforms them using the react
method we initialized earlier then pipes that outcome to <em>dist/src</em>. If you ran
this task, after you’d see that Gulp took all your JS files, converted your JSX
to JS, then outputted the results to a new <em>src</em> folder in a new <em>dist</em> folder -
all in a manner of milliseconds. Pretty rad.</p>
<p>Let’s create our next Gulp task. All this task is going to do is take our
<em>index.html</em> file and copy it over to our <em>dist</em> folder so our newly created JS
files from our transform Gulp task above can be referenced by our <em>index.html</em>
page.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'copy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(gulp.dest(path.DEST));
});
</code></pre>
<p>We’re now going to create our last Gulp task for development. What we want to do
is create a task that will always be running so when we change either our
<em>index.html</em> or any of the JS files, our two tasks from earlier will run and
update the code in the <em>dist</em> folder.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'watch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.watch(path.ALL, [<span class="hljs-string">'transform'</span>, <span class="hljs-string">'copy'</span>]);
});
</code></pre>
<p>What the task above is saying is watch all of our files, whenever any of them
change, run the transform task and the copy task. Pretty straightforward.</p>
<p>Now all we want to do for our development tasks is set up a default task. This
default task will run whenever we type <strong>gulp</strong> in our command line. Here’s the
code for that.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'default'</span>, [<span class="hljs-string">'watch'</span>]);
</code></pre>
<p>When we type <strong>gulp</strong>, Gulp will run the watch task, which we know watches our
files for changes and then runs the <strong>transform</strong> and <strong>copy</strong> tasks.</p>
<p>Those are all the tasks we’re going to create for developing. There are
obviously a plethora of other tasks you could create for dev, but those are what
we’ll stick with right now. At this point you should be able to run <strong>gulp</strong> and
the JSX in your <em>App.js</em> file will be converted to JS and the output will go to
<em>dist/src.</em> Your index.html file should have also been copied over to your dist
folder. Open your <em>index.html</em> page in the browser and you should see your
components being rendered.</p>
<p><strong>Production Gulp Tasks</strong></p>
<p>Now what we want to do is create a few gulp tasks for production so whenever we
run <strong>gulp build</strong> our code will prepare itself to get pushed to production.</p>
<p>The first task we’re going to build for production is called <strong>build</strong>. This
task is going to grab all of our JS files, concatenate all of them together,
minify them, then output the result to our <em>dist/build</em> folder. The code for
that looks like this.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'build'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.JS)
    .pipe(react())
    .pipe(concat(path.MINIFIED_OUT))
    .pipe(uglify(path.MINIFIED_OUT))
    .pipe(gulp.dest(path.DEST_BUILD));
});
</code></pre>
<p>The only thing that might look a little strange is the <em>path.OUT</em> argument we’re
passing to concat and uglify. All this is doing is telling both of those
functions what the resulting file path should be, so in this case, when we use
gulp.dest it’s going to take the <em>path.MINIFIED_OUT</em> file (<em>build.min.js</em>) and
output it to <em>path.DEST_BUILD</em> (<em>dist/build</em>).</p>
<p>Now you might notice this is cool, but at this point it’s a little annoying
because whenever we run <strong>gulp build</strong>, we then need to go and change our HTML
to reference the new <em>build.min.js</em> file rather than <em>src/App.js</em> and whatever
other script tags we’re referencing here. What if there were a way to, whenever
we ran our production gulp tasks, to replace all of our <code>&lt;script&gt;</code> tags with just
our new <code>&lt;script src=”build/build.mins.js”&gt;</code> script and then output that new
file to our dist folder? Well, there is. The way we’re going to do that is with
a <strong>gulp-html-replace</strong>. First, we need to head over to our index.html in our
main src folder and make some additions. Go ahead and modify the original
child/parent/App.js scripts to be wrapped in comments like this.</p>
<pre><code class="language-html"><span class="hljs-comment">&lt;!-- build:js --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/Child.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/Parent.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"src/App.js"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-comment">&lt;!-- endbuild --&gt;</span>
</code></pre>
<p>What’s going to happen is we’re going to tell Gulp, “Hey Gulp, when I tell you
to, concat and minify all my JS files and output them to a new <em>dist/build</em>
folder. As you’re doing that go to my copied <em>index.html</em> page in my <em>dist</em>
folder and replace the <strong>build:js</strong> comment and whatever is inside of it with
this new script tag <code>&lt;script src=&quot;build/build.min.js&quot;&gt;&lt;/script&gt;</code> but don’t
change my original <em>index.html</em> file in my normal <em>src</em> folder because I still
want to develop with that.”</p>
<p>Let’s now build out our replaceHTML task. The code should look like this</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(htmlreplace({
      <span class="hljs-string">'js'</span>: <span class="hljs-string">'build/'</span> + path.MINIFIED_OUT
    }))
    .pipe(gulp.dest(path.DEST));
});
</code></pre>
<p>Note that what we give htmlreplace is an object with a key that represents where
to replace and whose value is what to replace. That ‘js’ key in htmlreplace
coincides with** build:js** in our <em>index.html</em> page.</p>
<p>Very last step is now that both of our production tasks are ready, we need to
create another task that wraps both of those tasks in one. We do that with the
following code</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'production'</span>, [<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-string">'build'</span>]);
</code></pre>
<p>Now whenever we run <strong>gulp production</strong>, Gulp will run our <strong>replaceHTML</strong> and
<strong>build</strong> tasks. Go ahead and give it a try and check that your
<em>dist/index.html</em> and <em>dist/build/build.min.js</em> files are correct.</p>
<p>For reference, here’s the full <em>gulpfile.js</em> file.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);
<span class="hljs-keyword">var</span> concat = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-concat'</span>);
<span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>);
<span class="hljs-keyword">var</span> react = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-react'</span>);
<span class="hljs-keyword">var</span> htmlreplace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-html-replace'</span>);

<span class="hljs-keyword">var</span> path = {
  <span class="hljs-attr">HTML</span>: <span class="hljs-string">'src/index.html'</span>,
  <span class="hljs-attr">ALL</span>: [<span class="hljs-string">'src/js/*.js'</span>, <span class="hljs-string">'src/js/**/*.js'</span>, <span class="hljs-string">'src/index.html'</span>],
  <span class="hljs-attr">JS</span>: [<span class="hljs-string">'src/js/*.js'</span>, <span class="hljs-string">'src/js/**/*.js'</span>],
  <span class="hljs-attr">MINIFIED_OUT</span>: <span class="hljs-string">'build.min.js'</span>,
  <span class="hljs-attr">DEST_SRC</span>: <span class="hljs-string">'dist/src'</span>,
  <span class="hljs-attr">DEST_BUILD</span>: <span class="hljs-string">'dist/build'</span>,
  <span class="hljs-attr">DEST</span>: <span class="hljs-string">'dist'</span>
};

gulp.task(<span class="hljs-string">'transform'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.JS)
    .pipe(react())
    .pipe(gulp.dest(path.DEST_SRC));
});

gulp.task(<span class="hljs-string">'copy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(gulp.dest(path.DEST));
});

gulp.task(<span class="hljs-string">'watch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.watch(path.ALL, [<span class="hljs-string">'transform'</span>, <span class="hljs-string">'copy'</span>]);
});

gulp.task(<span class="hljs-string">'build'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.JS)
    .pipe(react())
    .pipe(concat(path.MINIFIED_OUT))
    .pipe(uglify(path.MINIFIED_OUT))
    .pipe(gulp.dest(path.DEST_BUILD));
});

gulp.task(<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(htmlreplace({
      <span class="hljs-string">'js'</span>: <span class="hljs-string">'build/'</span> + path.MINIFIED_OUT
    }))
    .pipe(gulp.dest(path.DEST));
});

gulp.task(<span class="hljs-string">'default'</span>, [<span class="hljs-string">'watch'</span>]);

gulp.task(<span class="hljs-string">'production'</span>, [<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-string">'build'</span>]);
</code></pre>
<p>At this point we have a full working build process using just Gulp. As you might
have noticed, this method has some weaknesses. First, you have to be very
careful how you load your different components in your HTML. Notice that we’re
loading the <em>Child.js</em> file before the <em>Parent.js</em> file. This makes sense
because <em>Parent.js</em> is dependent upon <em>Child.js</em>. Also note how we’re loading
<em>Parent.js</em> before we load <em>App.js</em>, again this is because Parent is required in
the <em>App.js</em> file. It might seem pretty straight forward in this example but as
your app grows, it’s very tricky to keep track of these Parent/Child
relationships and not to mention both Child and Parent are now in the global
scope, which from CS 101 we know is not a good thing. Another weakness in this
method is that if you put a debugger in our JSX, by the time our browser loads
that debugger we’re no longer in JSX land but in JS land and we have no way of
telling which line the error is on in our original JSX code. This isn’t ideal.
Although we still will always have to debug our transpiled JSX version, it would
be neat if we were able to still get the line numbers of where the error was at
in our original JSX file. Good news is when we introduce Browserify into our
build process, it will take care of both of these weaknesses and more.</p>
<p>At a fundamental level, all <a href="http://browserify.org/">Browserify</a> allows you to
do is require certain packages just like we did earlier with gulp, concat,
uglify, etc. This has huge benefits for us because not only do we now have
access to all of NPMs packages, but we’re now able to require only the packages
(or React components) we need to for that specific file. This solves our problem
of all of our components being on the global scope. Let’s take a quick look at
exporting and requiring modules.</p>
<p>I remember when I first started leaning about Browserify every definition about
it would be in terms of commonjs - which meant literally nothing to me because I
knew nothing about commonjs. That is until I fell upon
<a href="http://www.reddit.com/r/webdev/comments/2e0161/eli5_amd_commonjs_es6/">this</a>
article on Reddit. The author talks about how Commonjs, AMD, and ES6 Modules are
all ways to “break a Javascript project up into multiple self-contained modules
and managing the dependencies between them”. That makes sense. I can essentially
create module that can be passed around and used in other parts of my
application without having to pollute the global scope. The author continues,
“CommonJS is the standard implemented by Node. A file can assign any value
(including a function or object) to its module.exports property and any other
file can use require(“filename”) to get a copy of that value. It works great in
Node but isn’t usable in a web browser; because of a quirk of the way file
loading in HTML and Javascript works fetching each of the files would cause the
browser to hang until it was loaded. There are, however, some tools (browserify)
that will let you write your browser code in CommonJS and automatically convert
it to something web appropriate.” Then it clicked. All Browserify allows me to
do is have the greatness of using require in Node, but on the browser. This is
fantastic for React because as you’ve probably guessed by now, each React
component we create can be its own module that we can then require in other
components based off of need. Let’s take a look at some sample commonjs syntax.</p>
<p>We’re going to create three files (<strong><em>NOTE: This example (Add, Multiply, Math)
is just for demonstrating how Commonjs works, it’s not part of the overall
tutorial</em></strong>). The first file will be called <em>Add.js</em> and it will export an
object with an addition helper method on it. The second file will be called
<em>Multiply.js</em> and it will export an object with a multiplication helper method
on it. The third will be called <em>Math.js</em> where we require and then use our Add
and Multiply module.</p>
<p><strong>Add.js file</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> addObj  = {
  <span class="hljs-attr">add</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)</span>{
    <span class="hljs-keyword">return</span> x + y;
  }
};
<span class="hljs-built_in">module</span>.exports = addObj;
</code></pre>
<p><strong>Multply.js file</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> multiplyObj = {
  <span class="hljs-attr">multiply</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x,y</span>)</span>{
    <span class="hljs-keyword">return</span> x * y;
  }
};
<span class="hljs-built_in">module</span>.exports = multiplyObj;
</code></pre>
<p><strong>Math.js file</strong></p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> addObj = <span class="hljs-built_in">require</span>(‘./Add’);
<span class="hljs-keyword">var</span> multplyObj = <span class="hljs-built_in">require</span>(‘./Multiply’);

addObj.add(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>) <span class="hljs-comment">// 7</span>
multiplyObj.multiply(<span class="hljs-number">2</span>,<span class="hljs-number">5</span>) <span class="hljs-comment">// 10</span>
</code></pre>
<p>Just a few minor things to note about the code above. If you want a certain
object or function to be available in a different file, you use module.exports
to export your code.</p>
<p>If you want to require whatever was exported from a different file, you use
require and whatever the name of that file was minus the extension.</p>
<p>Now that we have a solid understanding of how Browserify can make our React code
more modular, let’s view the bigger picture of what our build process will look
like when we incorporate browserify. We’re still going to have two main tasks,
<strong>watch</strong> and <strong>build</strong>. <strong>watch</strong> for development and <strong>build</strong> for production.
On the surface both of these tasks will look very similar to our tasks before we
added Browserify. Our <strong>watch</strong> task is going to concat our JS files, transform
them from JSX to JS, and output the results into our <em>dist</em> folder. <strong>build</strong>
will also transform our JSX to JS, concatenate, minify, then output the result
to out <em>dist</em> folder. The process looks similar, but there are actually some
really cool features introduced by Browserify which we haven’t talked about.
We’ll get those more when we look at the code.</p>
<p>Let’s jump in.</p>
<p><strong>Browserify + Gulp + React (Development Tasks)</strong></p>
<p>Like before, we’re going to start out downloading all of the NPM packages we’ll
need for our new gulpfile. However, before we jump into that let’s hurry and
remove an NPM package we were using for the previous example that we won’t be
using for this example. In your terminal run</p>
<pre><code>npm uninstall gulp-concat;
</code></pre>
<p>This commands remove the Concat libraries from our <em>package.json</em> and our
<em>node_modules</em> folder.</p>
<p>Now let’s install the new NPM packages we will need. Run the following command
in your terminal.</p>
<pre><code>npm install --save-dev vinyl-source-stream;
npm install --save-dev browserify;
npm install --save-dev watchify;
npm install --save-dev reactify;
npm install --save-dev gulp-streamify;
</code></pre>
<p>We’ll get into what each of these packages do when we use them in our tasks.
Head over to your <em>gulpfile.js</em> and go ahead and remove everything. It’s easier
to start new since we’re introducing a pretty big change with browserify. At the
top of your gulpfile add the following code like we did before.</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);
<span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>);
<span class="hljs-keyword">var</span> htmlreplace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-html-replace'</span>);
<span class="hljs-keyword">var</span> source = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vinyl-source-stream'</span>);
<span class="hljs-keyword">var</span> browserify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browserify'</span>);
<span class="hljs-keyword">var</span> watchify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'watchify'</span>);
<span class="hljs-keyword">var</span> reactify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'reactify'</span>);
<span class="hljs-keyword">var</span> streamify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-streamify'</span>);

<span class="hljs-keyword">var</span> path = {
  <span class="hljs-attr">HTML</span>: <span class="hljs-string">'src/index.html'</span>,
  <span class="hljs-attr">MINIFIED_OUT</span>: <span class="hljs-string">'build.min.js'</span>,
  <span class="hljs-attr">OUT</span>: <span class="hljs-string">'build.js'</span>,
  <span class="hljs-attr">DEST</span>: <span class="hljs-string">'dist'</span>,
  <span class="hljs-attr">DEST_BUILD</span>: <span class="hljs-string">'dist/build'</span>,
  <span class="hljs-attr">DEST_SRC</span>: <span class="hljs-string">'dist/src'</span>,
  <span class="hljs-attr">ENTRY_POINT</span>: <span class="hljs-string">'./src/js/App.js'</span>
};
</code></pre>
<p>The first task we’re going to create is our copy task. This is exactly the same
as before. We’re taking our index.html page and copying it over to our <em>dist</em>
folder.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'copy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(gulp.dest(path.DEST));
});
</code></pre>
<p>Our next task is going to be our main task for development. This one is pretty
lengthy so I’ll post the code and we’ll walk through it.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'watch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  gulp.watch(path.HTML, [<span class="hljs-string">'copy'</span>]);

<span class="hljs-keyword">var</span> watcher  = watchify(browserify({
    <span class="hljs-attr">entries</span>: [path.ENTRY_POINT],
    <span class="hljs-attr">transform</span>: [reactify],
    <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cache</span>: {}, <span class="hljs-attr">packageCache</span>: {}, <span class="hljs-attr">fullPaths</span>: <span class="hljs-literal">true</span>
  }));

<span class="hljs-keyword">return</span> watcher.on(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    watcher.bundle()
      .pipe(source(path.OUT))
      .pipe(gulp.dest(path.DEST_SRC))
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Updated'</span>);
  })
    .bundle()
    .pipe(source(path.OUT))
    .pipe(gulp.dest(path.DEST_SRC));
});
</code></pre>
<p>The very first thing we do is tell Gulp to watch our <em>index.html</em> file for any
changes and if something does change, run the copy task.</p>
<p>The next thing we do is set up a watcher. Watchify works very closely with
Browserify. A problem that was occurring with these Browserify/React build
processes was that Browserify would take forever to transpile because it was
going through every component every single time anything changed and would
re-update the new bundled file. Watchify fixes this. Instead of going through
every file, Watchify will cache your files and only update the ones that need to
be updated. This makes builds take a LOT less time.</p>
<p>Notice we’re passing a browserify function invocation to our watchify function
invocation. Let’s now talk a bit about that browserify invocation. We’re passing
browserify an object that is going to essentially set up the configurations for
our browserify build. The first property on the object is <strong>entries</strong>. Notice
entries is an array with the path of just our main component in it (<em>app.js</em>).
You might remember earlier we had a JS array (<em>['src/js/</em>.js’,
'src/js/<em><em>/</em>.js’]</em>) which was every JS file we wanted to be transformed from JSX
to JS. Well one perk with browserify is that you just tell it the entry point or
the main component in your app and it will take care of all the child
components. Pretty slick. Next we have the <strong>transform</strong> property. Browserify
works with more than just React. Here is where we tell Browserify how to
transform our code. In this case, we’re using reactify which will take care of
our JSX to JS transpiling. Next is <strong>debug</strong> which is set to true. This tells
Browserify to use source maps. What source maps do is even though we’re
referencing the transpiled JSX in our index.html page, through source maps when
there is an error in our code, the error will point to the line number in our
JSX file rather than our transpiled JS file. This is super convenient for
debugging. That last line with <strong>cache: {}, packageCache: {}, fullPaths: true</strong>
is necessary, but we won’t go into it. The watchify website just states that
it’s needed in order to use watchify.</p>
<p>The next thing we’re going to do is set up our watcher to watch for updates in
our parent component or in any of its children components. We tell our watcher
to watch for updates then we pass it a callback function to invoke whenever
there is an update. The code in the callback should look fairly familiar.
**watcher.bundle() **concatenates all of our different components into one file
and does some browserify magic to make the module.exports/requires work. Then
the rest is just piping the result to our <em>dist/src</em> folder. The last thing in
our watch task is that we’re continuing to bundle and pipe after we set up the
on update callback. The reason for this is so that when we first call <strong>gulp
watch</strong> our code will bundle and pipe itself to the dist folder even before a
change is made. Then any changes made to our JS files after that will just
overwrite the initial bundled code.</p>
<p>The last thing for our development tasks is to set the default gulp task to run
the watch task so we can now just run <strong>gulp</strong> and our watch task will kick off.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'default'</span>, [<span class="hljs-string">'watch'</span>]);
</code></pre>
<h4><strong>Browserify + Gulp + React (Production Tasks)</strong></h4>
<p>Just like before we started using Browserify, I like to keep my Development and
Production tasks separate. Like before, create a gulp task called <strong>build</strong>.
This task is going to be very similar to our <strong>watch</strong> task except this one is
only going to bundle and pipe our code without actually watching it for updates.
It’s also going to minify the final code then output it to <em>dist/build</em> rather
than <em>dist/src</em>.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'build'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  browserify({
    <span class="hljs-attr">entries</span>: [path.ENTRY_POINT],
    <span class="hljs-attr">transform</span>: [reactify]
  })
    .bundle()
    .pipe(source(path.MINIFIED_OUT))
    .pipe(streamify(uglify(path.MINIFIED_OUT)))
    .pipe(gulp.dest(path.DEST_BUILD));
});
</code></pre>
<p>Like I mentioned, this is mostly the same. We got rid of source mapping and our
watchify stuff and added minification, but that’s it.</p>
<p>Also exactly like before we used Browserify, we want to be able to modify our
index.html page when it’s ready for production and switch out our regular
scripts with the minified versions. We’ll use the same <strong>replaceHTML</strong> task that
we used before to do this.</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(htmlreplace({
      <span class="hljs-string">'js'</span>: <span class="hljs-string">'build/'</span> + path.MINIFIED_OUT
    }))
    .pipe(gulp.dest(path.DEST));
});
</code></pre>
<p>and to wrap both of our production tasks into one gulp process,</p>
<pre><code class="language-javascript">gulp.task(<span class="hljs-string">'production'</span>, [<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-string">'build'</span>]);
</code></pre>
<p>and that’s it! Here’s what the full <em>gulpfile.js</em> should look like</p>
<pre><code class="language-javascript"><span class="hljs-keyword">var</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp'</span>);
<span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>);
<span class="hljs-keyword">var</span> htmlreplace = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-html-replace'</span>);
<span class="hljs-keyword">var</span> source = <span class="hljs-built_in">require</span>(<span class="hljs-string">'vinyl-source-stream'</span>);
<span class="hljs-keyword">var</span> browserify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'browserify'</span>);
<span class="hljs-keyword">var</span> watchify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'watchify'</span>);
<span class="hljs-keyword">var</span> reactify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'reactify'</span>);
<span class="hljs-keyword">var</span> streamify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-streamify'</span>);

<span class="hljs-keyword">var</span> path = {
  <span class="hljs-attr">HTML</span>: <span class="hljs-string">'src/index.html'</span>,
  <span class="hljs-attr">MINIFIED_OUT</span>: <span class="hljs-string">'build.min.js'</span>,
  <span class="hljs-attr">OUT</span>: <span class="hljs-string">'build.js'</span>,
  <span class="hljs-attr">DEST</span>: <span class="hljs-string">'dist'</span>,
  <span class="hljs-attr">DEST_BUILD</span>: <span class="hljs-string">'dist/build'</span>,
  <span class="hljs-attr">DEST_SRC</span>: <span class="hljs-string">'dist/src'</span>,
  <span class="hljs-attr">ENTRY_POINT</span>: <span class="hljs-string">'./src/js/App.js'</span>
};

gulp.task(<span class="hljs-string">'copy'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(gulp.dest(path.DEST));
});

gulp.task(<span class="hljs-string">'watch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  gulp.watch(path.HTML, [<span class="hljs-string">'copy'</span>]);

<span class="hljs-keyword">var</span> watcher  = watchify(browserify({
    <span class="hljs-attr">entries</span>: [path.ENTRY_POINT],
    <span class="hljs-attr">transform</span>: [reactify],
    <span class="hljs-attr">debug</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">cache</span>: {}, <span class="hljs-attr">packageCache</span>: {}, <span class="hljs-attr">fullPaths</span>: <span class="hljs-literal">true</span>
  }));

<span class="hljs-keyword">return</span> watcher.on(<span class="hljs-string">'update'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
    watcher.bundle()
      .pipe(source(path.OUT))
      .pipe(gulp.dest(path.DEST_SRC))
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Updated'</span>);
  })
    .bundle()
    .pipe(source(path.OUT))
    .pipe(gulp.dest(path.DEST_SRC));
});

gulp.task(<span class="hljs-string">'build'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  browserify({
    <span class="hljs-attr">entries</span>: [path.ENTRY_POINT],
    <span class="hljs-attr">transform</span>: [reactify],
  })
    .bundle()
    .pipe(source(path.MINIFIED_OUT))
    .pipe(streamify(uglify(path.MINIFIED_OUT)))
    .pipe(gulp.dest(path.DEST_BUILD));
});

gulp.task(<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  gulp.src(path.HTML)
    .pipe(htmlreplace({
      <span class="hljs-string">'js'</span>: <span class="hljs-string">'build/'</span> + path.MINIFIED_OUT
    }))
    .pipe(gulp.dest(path.DEST));
});

gulp.task(<span class="hljs-string">'production'</span>, [<span class="hljs-string">'replaceHTML'</span>, <span class="hljs-string">'build'</span>]);

gulp.task(<span class="hljs-string">'default'</span>, [<span class="hljs-string">'watch'</span>]);
</code></pre>
<p>You now have a very nice build process that has some very nice features. To
recap, those features include</p>
<ul>
<li>JSX to JS transformation</li>
<li>Source maps for debugging</li>
<li>Fast since Watchify only updating the necessary files</li>
<li>More modularity with browserify</li>
<li>Require only the files you need when you need them</li>
<li>You only need to give browserify your most parent component and it takes care of the rest.</li>
</ul>
<p>I hope this tutorial was useful for you.
At this point you should be fairly comfortable with React and its different
pieces. You should also have an idea of how to setup a build process using Gulp
and Browserify to compliment your React development. Up next, Flux and how to
better architect your React.js applications.</p>
</div></div><div class="footer" data-reactid="11"><a style="text-decoration:underline;" href="https://twitter.com/tylermcginnis33" data-reactid="12">Tyler McGinnis</a></div></div></div></div></div></div><script src="/bundle.js?t=1481772903476"></script></body></html>